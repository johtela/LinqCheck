---
ProjectName: LinqCheck
Logo: images/LinqCheck.svg
GitHub: https://github.com/johtela/LinqCheck
Footer: "Copyright © 2018 Tommi Johtela"
License: License.html
MarkdownStyle: modern
SyntaxHighlight: son-of-obsidian
ShowDescriptionsInToc: true
UseDiagrams: true
DiagramStyle: mermaid
UseMath: true
---
# LinqCheck - Property Based Testing with LINQ Expressions

> There are two ways of constructing a software design: One way is to make it 
> so simple that there are obviously no deficiencies, and the other way is to 
> make it so complicated that there are no obvious deficiencies. The first 
> method is far more difficult. 
> 
> _C.A.R. Hoare in his 1980 Turing Award Lecture_

Although [Tony Hoare's](https://en.wikipedia.org/wiki/Tony_Hoare) famous quote 
is undoubtedly correct, it is increasingly difficult nowadays to design software 
so simple that it is obviously bug-free by design. Software gets more and more 
complex every day, and the best strategy we have to assure its quality is to 
test it thoroughly. 

Another famous quote by Edsger W. Dijkstra says that testing shows the presence, 
not the absence of bugs. However, the term testing can refer to many types of
activities. We should recognize that the number and types of bugs we find 
varies greatly depending on the kind of testing we perform. The more 
strict and systematic our approach is, the more value we gain from it.

The problem is that testing can be a very tedious and time consuming task. Even
automated tests require a lot of work and discipline to be effective in
discovering bugs. So, we should continuously seek ways to improve our testing 
strategies, and explore new methods with an open mind. The best we could hope
for is a technique which reduces the amount of test code we need to write while 
revealing more bugs, and even new kinds of bugs. Is there an approach that 
could satisfy these requirements? I think there is.

## Property Based Testing

Property based testing refers to a software verification method where the
test cases are generated by a computer. This tehcnique was first introduced in 
the [QuickCheck](https://en.wikipedia.org/wiki/QuickCheck) library, 
originally developed for the purely functional programming language 
[Haskell](https://www.haskell.org/). As the name of the method implies, instead 
of testing individual scenarios, we write down the properties that should hold 
for arbitrary input data. The testing framework will produce random inputs 
that might break the specified properties. In a sense, the software is trying 
to prove our assumptions wrong by searching for counter examples.

If the library finds a case where one or more properties do no hold, it will 
reduce the case to a minimal example that still fails. This is a much better 
starting point to analyzing the problem, than getting an exception or 
assertion error in the middle of a program execution. The flow of events
that lead to the error could be numerous and hard to recreate. Also, it is 
might be difficult to discern which actions are relevant for reproducing
the problem and which are not.

Property based testing generally works best for testing pure functions
whose result depend only on the input. However, the co-inventor of QuickCheck 
[John Hughes](https://en.wikipedia.org/wiki/John_Hughes_(computer_scientist))
has demonstrated that it is possible to also test imperative programs with
property based testing. Rather than generating input data directly, we create 
sequences of function calls that modify programs's mutable state. When a 
failing sequence is found, the library can again reduce it to a minimal 
example that produces the same error.

There are a lot of resources in the Internet to learn more about property
based testing, but I would recommend the reading the
[original paper](http://www.eecs.northwestern.edu/~robby/courses/395-495-2009-fall/quick.pdf)
by Hughes and Koen Classen. It not only introduces the concept but also
explains how the library is implemented in a clear way. The paper assumes
the reader to be familiar with Haskell, which might be an obstacle. But if you 
are, the paper demystifies the concept which might feel like magic at first.

## LinqCheck

As you might have guessed LinqCheck is basically a port of QuickCheck for C#.
It implements all of the concepts present in QuickCheck, and tries to provide 
an API which feels natural in C#, not mimicing the original design too much.
It also serves as an example of how to program in C# like it was a functional 
programming language. You can get surprisingly far with C# language 
features and write elegant and readable code, if you follow the functional
principles. It goes to prove that the ideas of FP are applicable widely,
and it pays of to learn functional programming languages, even if you are 
not using one in your daily work.

Another feature you might have figured from the name is that LinqCheck 
utilizes the syntactic sugaring provided by LINQ - heavily. It is no 
coincidence that the way how LINQ expressions work resembles the concept of 
[monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) in 
Haskell. [Erik Meijer](https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)),
who is widely credited to be the father of LINQ, was also involved in the
design of Haskell language and compiler. Understanding the correspondence
between monads and LINQ helps transferring some of the features from QuickCheck
to C#. 

## Getting Started

It is easiest to look at a few examples first on how LinqCheck is used. The
concepts of LinqCheck are introduced in the Examples section. If you are 
interested only to use the library, you can stop there. But if you want to
learn how the library is implemented, you can continue reading the 
documentation that is generated with the 
[Literate Programming](https://johtela.github.io/LiterateProgramming/) tool.
That tool is actually a great accompanion to LinqCheck. By documenting your
properties you will also get live documentation for your tests, and 
essentially a specification on how the code you are testing works.

